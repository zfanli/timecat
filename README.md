# timecat

Track a day in a few words - An analyzer of your time utilization.

一句话搞定日常记录，一个工具用来分析你的时间利用率。

## idea

我使用过很多方式去追踪一天时间的使用，尝试优化我的时间管理，比如使用附带一天 24 小时时刻的时间记录本，或者是时间块等手机 APP。它们确实给我带了警示，让我看见了我对时间管理中的不合理，并催促我着手去改善。

这很不错，但是为此每天我需要在睡前花 15 分钟回忆过去 24 小时我在做什么。刚开始我感觉很新鲜，感觉时间在我的掌握之下。不过随着新鲜感迅速褪去，我终于知道这是一件很枯燥的事情。于是在一次忙碌之中，我忘记了记录当天的时间，第二天发现时，我已经无法回忆起过去的这天每个小时我在做什么。强烈的沮丧感使我放弃继续这样每日记录时间。

从这些经历中我能体会到的是，只有足够简单的记录方式，才能让我良好的保持时间记录的习惯；而只有让我保持时间记录的习惯，留下珍贵的数据，才能进行下一步的分析帮助我进行时间管理的优化。对新的工具寻找无果之下，我决定尝试自己设计并开发一个应用，满足自己的需求。

这个应用首先需要足够简单的记录方式。但是，足够简单也意味着精度的缺失，所以如何在精度和简单度中保持平衡，对后期数据处理有着非常关键的影响，毕竟如果记录几个月后尝试分析的时候才发现，因为当初数据记录不充分而导致无法作出更有用的分析，对谁来说都是非常令人沮丧的。

这意味着，对于一个时间管理的应用来说，数据结构设计的重要性是远大于分析功能的。道理显而易见，没有足够的数据支持，分析功能就显得无用武之地了。

## 数据结构

为了保证用户录入尽量简单的信息，而程序处理时能还原出更多的信息。用户每日记录至少要包含以下的信息。

### 时间（可选）

当日时间不需要手动输入，如果要对过去的日期进行设定才需要选择。

### 主题

主题表述做了什么。需要准确的前提下尽量精简，最好是用一个词就能概括。可以多个，但建议不要超过三个。例如：画画、运动、休息、学习 Swift。

### 利用率

表述做了多久。可以用百分比表示，也可以用时间表示。用百分比表示时，最终的结果是你设定的每日可利用时间乘以这个百分比的结果。用时间表示时不超过你设定的每日可利用时间。时间利用率需要真实反映，并不是要强行填充满你的可利用时间。

### 工作日 or 非工作日（可选）

工作日和非工作日的可利用时间不同，默认情况下程序会根据当前日期来计算是否为工作日，但是当实际情况和日历不符时可以手动修改。

一个符合以上信息的用户录入例子：

最长的情况 ->

```
2019/6/8, 运动, 2h, 画画, 2h, ..., 非工作日
```

一般情况 -> (时间和是否工作日程序自动算出)

```
运动, 画画, 4h
```

最终反映到数据上，每天的信息应该是这样的：

```jsonc
{
  "2019/6/8": {
    "subject": {
      "运动": 0.5,
      "画画": 0.5
    },
    "isWorkday": false
  }
}
```

可以得出结构如下。

```jsonc
{
  "时间": {
    "主题": {
      "主题1": "利用率1"
      // ...
    },
    "是否工作日": "是 or 否"
  }
}
```

另外，每日的数据需要配合设置的支持。对设置来说需要提供下面的信息。

### 预期可利用时间

分工作日和非工作日，可以直接输入，可以根据算式输入。

根据算式录入时提供下面的工作日可利用时间算式。

```
可利用时间 = (每日 24 小时 - 工作时间 w 小时 - 通勤时间 c 小时 - 睡眠时间 s 小时) * 预期可利用率 e

我的可利用时间 = (24 - 8 - 3 - 8) * 80% = 4h
```

对于使用算式的场景，工作时间 `w`、通勤时间 `c`、睡眠时间 `s` 以及实际可以利用率 `e` 是用户可定义项。

工作时间、通勤时间和睡眠时间真实填写即可。实际可利用率的设定是希望在剩余的时间内给予一定缓冲，例如除此之外我希望将吃饭、家务的时间除外，显然这不是一个可以精确控制的时间，至少对我来说是如此，我希望让剩余的时间中分配 20% 时间用来处理这些杂事，所以我的实际可利用率设定为 80%。

这是一个可以自己灵活设定的时间，如果你没有这些杂物，并且希望自己严格利用所有时间，你可以设定 100%；或者你的杂物繁多，可能需要更多的时间完成，那么或许你应该设置为 50%。

非工作日算式类似。

```
可利用时间 = (每日 24 小时 - 固定时间 f 小时 - 睡眠时间 s 小时) * 预期可利用率 e

我的可利用时间 = (24 - 4 - 10) * 100% = 8h
```

固定时间是需要处理杂物的时间，例如做饭、家务等，当然这个可以自己定义，你可以把做家务的时间作为有效利用时间，并且对其进行追踪和分析。

关于预期可利用时间的设置数据结构如下。

```jsonc
{
  "expectAvailableTime": {
    "workday": "",
    "nonworkday": "",
    "formula": {
      "workday": {
        "workHours": 8,
        "commuteHours": 3,
        "sleepHours": 8,
        "expectUsage": 0.8
      },
      "nonWorkday": {
        "fixedHours": 4,
        "sleepHours": 8,
        "expectUsage": 1
      }
    }
  }
}
```

### 特殊时间

默认将一周的周一到周五作为工作日，周末作为非工作日。提供选项询问是否开启默认假日模式，按照国家法定假日判断日期是否为工作日。

但是除此之外，还需要记录用户的特殊时间段。在设置数据中保有一份特殊日清单，在每个日期做判断时检查，这只是一个可选项目，用来给未来的时间段设定特殊日，这样到了这一天时程序会显示出用户定义的正确的工作日或非工作日信息。

但是最终结果用户可以在当天录入时手动修正。

这部分设置数据应该如下。

```jsonc
{
  // 默认周一到周五是工作日
  "workday": [0, 1, 2, 3, 4],
  // 周末是非工作日
  "nonWorkday": [5, 6],
  "specialDays": {
    "2019/6/8": false
    // ...
    // "date": isWorkday(:Boolean)
  }
}
```

### Final Data Sctructure

```json
{
  "dailyData": {
    "2019": {
      "6": {
        "8": {
          "subject": {
            "subject1": 0.4,
            "subject2": "2h"
          },
          "isWorkday": false
        }
      }
    }
  },
  "settings": {
    "expectAvailableTime": {
      "workday": "",
      "nonworkday": "",
      "formula": {
        "workday": {
          "workHours": 8,
          "commuteHours": 3,
          "sleepHours": 8,
          "expectUsage": 0.8
        },
        "nonWorkday": {
          "fixedHours": 4,
          "sleepHours": 8,
          "expectUsage": 1
        }
      }
    },
    "days": {
      "workday": [0, 1, 2, 3, 4],
      "nonWorkday": [5, 6],
      "specialDays": {
        "2019/6/8": false
      }
    }
  }
}
```
